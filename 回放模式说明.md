# FlowReplay 回放模式说明

## 问题背景

你提出了一个非常重要的问题：**回放时如何保证请求的执行顺序？**

在原系统中，如果先执行A请求再执行B请求，那么回放时也需要按照这个顺序执行。否则可能导致：
- B请求依赖A请求的结果（如A创建订单，B查询订单）
- 数据不一致
- 回放失败

## 原有问题

之前的实现使用了 Virtual Threads 并发执行所有请求：

```java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    for (int i = 0; i < records.size(); i++) {
        executor.submit(() -> {
            // 所有请求并发执行，顺序无法保证！
        });
    }
}
```

**问题**：虽然结果的顺序是对的，但**请求的执行顺序是乱的**！

## 解决方案

现在 FlowReplay 支持两种回放模式：

### 1. 顺序回放模式（Sequential Mode）- **默认模式**

**特点**：
- ✅ 严格按照录制顺序依次执行请求
- ✅ 保证请求的执行顺序与录制时一致
- ✅ 适合有依赖关系的请求场景
- ⚠️ 性能较慢（串行执行）

**实现原理**：
```java
for (int i = 0; i < records.size(); i++) {
    TrafficRecord record = records.get(i);
    // 依次执行，等待上一个请求完成后再执行下一个
    ReplayResult result = replayHttp(record);
    results.add(result);
}
```

**使用场景**：
- 请求之间有依赖关系（如创建→查询→更新）
- 需要验证业务流程的正确性
- 回归测试
- 系统重构验证

### 2. 并发回放模式（Concurrent Mode）

**特点**：
- ✅ 使用 Virtual Threads 并发执行所有请求
- ✅ 性能高，速度快
- ❌ 不保证请求的执行顺序
- ✅ 结果顺序与录制顺序一致（通过数组索引保证）

**实现原理**：
```java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    for (int i = 0; i < records.size(); i++) {
        executor.submit(() -> {
            // 并发执行，但结果按索引存储
            resultsArray[index] = replayHttp(record);
        });
    }
}
```

**使用场景**：
- 请求之间相互独立，无依赖关系
- 性能压测
- 大量数据的快速回放
- 只关注结果，不关注执行顺序

## 使用方法

### 1. 顺序回放（默认）

```bash
# 方式1：不指定模式（默认为顺序回放）
java -jar flowreplay-cli-1.0.0-SNAPSHOT-jar-with-dependencies.jar replay \
  --input ./recordings \
  --target http://localhost:9090 \
  --compare \
  --report ./report.html

# 方式2：显式指定顺序模式
java -jar flowreplay-cli-1.0.0-SNAPSHOT-jar-with-dependencies.jar replay \
  --input ./recordings \
  --target http://localhost:9090 \
  --mode sequential \
  --compare \
  --report ./report.html
```

### 2. 并发回放

```bash
java -jar flowreplay-cli-1.0.0-SNAPSHOT-jar-with-dependencies.jar replay \
  --input ./recordings \
  --target http://localhost:9090 \
  --mode concurrent \
  --compare \
  --report ./report.html
```

## 模式对比

| 特性 | 顺序回放 (sequential) | 并发回放 (concurrent) |
|------|---------------------|---------------------|
| 执行顺序 | ✅ 严格按录制顺序 | ❌ 无序，并发执行 |
| 结果顺序 | ✅ 与录制顺序一致 | ✅ 与录制顺序一致 |
| 性能 | ⚠️ 较慢（串行） | ✅ 快速（并发） |
| 适用场景 | 有依赖关系的请求 | 独立的请求 |
| 默认模式 | ✅ 是 | ❌ 否 |

## 实际案例

### 案例1：电商订单流程（需要顺序回放）

**场景**：
1. 创建订单（POST /api/order/create）
2. 查询订单（GET /api/order/123）
3. 支付订单（POST /api/order/123/pay）
4. 查询支付状态（GET /api/order/123/payment）

**问题**：如果使用并发回放，可能出现：
- 步骤2在步骤1之前执行 → 查询不到订单
- 步骤3在步骤1之前执行 → 支付失败

**解决方案**：使用顺序回放
```bash
flowreplay replay --input ./recordings --target http://localhost:9090 --mode sequential
```

### 案例2：独立查询接口（可以并发回放）

**场景**：
1. 查询用户信息（GET /api/user/1）
2. 查询商品列表（GET /api/product/list）
3. 查询分类信息（GET /api/category/list）
4. 查询推荐商品（GET /api/product/recommend）

**特点**：所有请求相互独立，无依赖关系

**解决方案**：使用并发回放提升性能
```bash
flowreplay replay --input ./recordings --target http://localhost:9090 --mode concurrent
```

## 重要说明

### 1. 默认使用顺序回放

为了保证数据一致性和业务流程的正确性，FlowReplay **默认使用顺序回放模式**。

### 2. 何时使用并发回放

只有在以下情况下才建议使用并发回放：
- ✅ 确认所有请求相互独立
- ✅ 不关心执行顺序
- ✅ 需要快速完成回放
- ✅ 进行性能压测

### 3. 性能差异

假设有100个请求，每个请求耗时100ms：
- **顺序回放**：总耗时 = 100 × 100ms = 10秒
- **并发回放**：总耗时 ≈ 100ms（所有请求同时执行）

## 技术实现细节

### 修改的文件

1. **TrafficReplayer.java**
   - 新增 `sequentialMode` 字段
   - 新增 `replaySequential()` 方法（顺序回放）
   - 重命名原方法为 `replayConcurrent()`（并发回放）
   - `replay()` 方法根据模式选择执行方式

2. **FlowReplayCLI.java**
   - 新增 `--mode` 参数解析
   - 默认值为 `sequential`
   - 传递模式参数到 `TrafficReplayer`

### 代码示例

**顺序回放实现**：
```java
private List<ReplayResult> replaySequential(List<TrafficRecord> records) {
    List<ReplayResult> results = new ArrayList<>();
    for (TrafficRecord record : records) {
        // 依次执行，保证顺序
        ReplayResult result = replayHttp(record);
        results.add(result);
    }
    return results;
}
```

**并发回放实现**：
```java
private List<ReplayResult> replayConcurrent(List<TrafficRecord> records) {
    ReplayResult[] resultsArray = new ReplayResult[records.size()];
    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
        for (int i = 0; i < records.size(); i++) {
            final int index = i;
            executor.submit(() -> {
                resultsArray[index] = replayHttp(record);
            });
        }
    }
    return List.of(resultsArray);
}
```

